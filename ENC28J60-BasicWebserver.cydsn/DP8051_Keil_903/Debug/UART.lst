C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\DP8051_Keil_903\Debug\UART.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\2.1\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\UART.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051_Keil_903\Debug\UART.lst) CD DB NOIP OT(0,SIZE) 
                    -INCDIR(Generated_Source\PSoC3) OJ(.\DP8051_Keil_903\Debug\UART.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART.c
   3          * Version 2.20
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions, 
  13          * disclaimers, and limitations in the end user license agreement accompanying 
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART.h"
  18          #include "CyLib.h"
  19          
  20          
  21          /***************************************
  22          * Global data allocation
  23          ***************************************/
  24          
  25          #if( UART_TX_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
                  volatile uint8 UART_txBuffer[UART_TXBUFFERSIZE];
                  volatile uint8 UART_txBufferRead = 0u;
                  uint8 UART_txBufferWrite = 0u;
              #endif /* End UART_TX_ENABLED */
  30          #if( ( UART_RX_ENABLED || UART_HD_ENABLED ) && \
  31               (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
                  volatile uint8 UART_rxBuffer[UART_RXBUFFERSIZE];
                  volatile uint8 UART_rxBufferRead = 0u;
                  volatile uint8 UART_rxBufferWrite = 0u;
                  volatile uint8 UART_rxBufferLoopDetect = 0u;
                  volatile uint8 UART_rxBufferOverflow = 0u;
                  #if (UART_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_rxAddressMode = UART_RXADDRESSMODE;
                      volatile uint8 UART_rxAddressDetected = 0u;
                  #endif /* End EnableHWAddress */    
              #endif /* End UART_RX_ENABLED */
  42          
  43          
  44          /***************************************
  45          * Local data allocation
  46          ***************************************/
  47          
  48          uint8 UART_initVar = 0u;
  49          
  50          
  51          /*******************************************************************************
  52          * Function Name: UART_Start
  53          ********************************************************************************
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 2   

  54          *
  55          * Summary:
  56          *  Initialize and Enable the UART component.
  57          *  Enable the clock input to enable operation.
  58          *
  59          * Parameters:
  60          *  None.
  61          *
  62          * Return:
  63          *  None.
  64          *
  65          * Global variables:
  66          *  The UART_intiVar variable is used to indicate initial 
  67          *  configuration of this component. The variable is initialized to zero (0u) 
  68          *  and set to one (1u) the first time UART_Start() is called. This allows for 
  69          *  component initialization without re-initialization in all subsequent calls 
  70          *  to the UART_Start() routine. 
  71          *
  72          * Reentrant:
  73          *  No.
  74          *
  75          *******************************************************************************/
  76          void UART_Start(void) 
  77          {
  78   1          /* If not Initialized then initialize all required hardware and software */
  79   1          if(UART_initVar == 0u)
  80   1          {
  81   2              UART_Init();
  82   2              UART_initVar = 1u;
  83   2          }
  84   1          UART_Enable();
  85   1      }
  86          
  87          
  88          /*******************************************************************************
  89          * Function Name: UART_Init
  90          ********************************************************************************
  91          *
  92          * Summary:
  93          *  Initialize component's parameters to the parameters set by user in the
  94          *  customizer of the component placed onto schematic. Usually called in
  95          *  UART_Start().
  96          *
  97          * Parameters:
  98          *  None.
  99          *
 100          * Return:
 101          *  None.
 102          *
 103          *******************************************************************************/
 104          void UART_Init(void) 
 105          {
 106   1          #if(UART_RX_ENABLED || UART_HD_ENABLED)
              
                      #if(UART_RX_INTERRUPT_ENABLED && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
                          /* Set the RX Interrupt. */
                          CyIntSetVector(UART_RX_VECT_NUM,   UART_RXISR);
                          CyIntSetPriority(UART_RX_VECT_NUM, UART_RX_PRIOR_NUM);
                      #endif /* End UART_RX_INTERRUPT_ENABLED */
              
                      #if (UART_RXHW_ADDRESS_ENABLED)
                          UART_SetRxAddressMode(UART_RXAddressMode);
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 3   

                          UART_SetRxAddress1(UART_RXHWADDRESS1);
                          UART_SetRxAddress2(UART_RXHWADDRESS2);
                      #endif /* End UART_RXHW_ADDRESS_ENABLED */
              
                      /* Configure the Initial RX interrupt mask */
                      UART_RXSTATUS_MASK_REG  = UART_INIT_RX_INTERRUPTS_MASK;
                  #endif /* End UART_RX_ENABLED || UART_HD_ENABLED*/
 123   1      
 124   1          #if(UART_TX_ENABLED)
 125   1              #if(UART_TX_INTERRUPT_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
                          /* Set the TX Interrupt. */
                          CyIntSetVector(UART_TX_VECT_NUM,   UART_TXISR);
                          CyIntSetPriority(UART_TX_VECT_NUM, UART_TX_PRIOR_NUM);
                      #endif /* End UART_TX_INTERRUPT_ENABLED */
 130   1      
 131   1              /* Write Counter Value for TX Bit Clk Generator*/
 132   1              #if(UART_TXCLKGEN_DP)
 133   1                  UART_TXBITCLKGEN_CTR_REG = UART_BIT_CENTER;
 134   1                  UART_TXBITCLKTX_COMPLETE_REG = (UART_NUMBER_OF_DATA_BITS + \
 135   1                                                          UART_NUMBER_OF_START_BIT) * \
 136   1                                                          UART_OVER_SAMPLE_COUNT;
 137   1              #else
                          UART_TXBITCTR_COUNTER_REG = (UART_NUMBER_OF_DATA_BITS + \
                                                                  UART_NUMBER_OF_START_BIT) * \
                                                                  UART_OVER_SAMPLE_8;
                      #endif /* End UART_TXCLKGEN_DP */
 142   1      
 143   1              /* Configure the Initial TX interrupt mask */
 144   1              #if(UART_TX_INTERRUPT_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
                          UART_TXSTATUS_MASK_REG = UART_TX_STS_FIFO_EMPTY;
                      #else
 147   1                  UART_TXSTATUS_MASK_REG = UART_INIT_TX_INTERRUPTS_MASK;
 148   1              #endif /*End UART_TX_INTERRUPT_ENABLED*/
 149   1              
 150   1          #endif /* End UART_TX_ENABLED */
 151   1      
 152   1          #if(UART_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_WriteControlRegister( \
                          (UART_ReadControlRegister() & ~UART_CTRL_PARITY_TYPE_MASK) | \
                          (UART_PARITY_TYPE << UART_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_PARITY_TYPE_SW */
 157   1      }
 158          
 159          
 160          /*******************************************************************************
 161          * Function Name: UART_Enable
 162          ********************************************************************************
 163          *
 164          * Summary:
 165          *  Enables the UART block operation
 166          *
 167          * Parameters:
 168          *  None.
 169          *
 170          * Return:
 171          *  None.
 172          *
 173          * Global Variables:
 174          *  UART_rxAddressDetected - set to initial state (0).
 175          *
 176          *******************************************************************************/
 177          void UART_Enable(void) 
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 4   

 178          {
 179   1          uint8 enableInterrupts;
 180   1          enableInterrupts = CyEnterCriticalSection();
 181   1          
 182   1          #if(UART_RX_ENABLED || UART_HD_ENABLED)
                      /*RX Counter (Count7) Enable */
                      UART_RXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
                      /* Enable the RX Interrupt. */
                      UART_RXSTATUS_ACTL_REG  |= UART_INT_ENABLE;
                      #if(UART_RX_INTERRUPT_ENABLED && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
                          CyIntEnable(UART_RX_VECT_NUM);
                          #if (UART_RXHW_ADDRESS_ENABLED)
                              UART_rxAddressDetected = 0u;
                          #endif /* End UART_RXHW_ADDRESS_ENABLED */
                      #endif /* End UART_RX_INTERRUPT_ENABLED */
                  #endif /* End UART_RX_ENABLED || UART_HD_ENABLED*/
 194   1      
 195   1          #if(UART_TX_ENABLED)
 196   1              /*TX Counter (DP/Count7) Enable */
 197   1              #if(!UART_TXCLKGEN_DP)
                          UART_TXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
                      #endif /* End UART_TXCLKGEN_DP */
 200   1              /* Enable the TX Interrupt. */
 201   1              UART_TXSTATUS_ACTL_REG |= UART_INT_ENABLE;
 202   1              #if(UART_TX_INTERRUPT_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
                          CyIntEnable(UART_TX_VECT_NUM);
                      #endif /* End UART_TX_INTERRUPT_ENABLED*/
 205   1           #endif /* End UART_TX_ENABLED */
 206   1      
 207   1          #if(UART_INTERNAL_CLOCK_USED)
 208   1              /* Set the bit to enable the clock. */
 209   1              UART_INTCLOCK_CLKEN_REG |= UART_INTCLOCK_CLKEN_MASK;
 210   1          #endif /* End UART_INTERNAL_CLOCK_USED */
 211   1          
 212   1          CyExitCriticalSection(enableInterrupts);
 213   1      }
 214          
 215          
 216          /*******************************************************************************
 217          * Function Name: UART_Stop
 218          ********************************************************************************
 219          *
 220          * Summary:
 221          *  Disable the UART component
 222          *
 223          * Parameters:
 224          *  None.
 225          *
 226          * Return:
 227          *  None.
 228          *
 229          *******************************************************************************/
 230          void UART_Stop(void) 
 231          {
 232   1          uint8 enableInterrupts;
 233   1          enableInterrupts = CyEnterCriticalSection();
 234   1      
 235   1          /*Write Bit Counter Disable */
 236   1          #if(UART_RX_ENABLED || UART_HD_ENABLED)
                      UART_RXBITCTR_CONTROL_REG &= ~UART_CNTR_ENABLE;
                  #endif /* End UART_RX_ENABLED */
 239   1      
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 5   

 240   1          #if(UART_TX_ENABLED)
 241   1              #if(!UART_TXCLKGEN_DP)
                          UART_TXBITCTR_CONTROL_REG &= ~UART_CNTR_ENABLE;
                      #endif /* End UART_TXCLKGEN_DP */
 244   1          #endif /* UART_TX_ENABLED */
 245   1      
 246   1          #if(UART_INTERNAL_CLOCK_USED)
 247   1              /* Clear the bit to enable the clock. */
 248   1              UART_INTCLOCK_CLKEN_REG &= ~UART_INTCLOCK_CLKEN_MASK;
 249   1          #endif /* End UART_INTERNAL_CLOCK_USED */
 250   1          
 251   1          /*Disable internal interrupt component*/
 252   1          #if(UART_RX_ENABLED || UART_HD_ENABLED)
                      UART_RXSTATUS_ACTL_REG  &= ~UART_INT_ENABLE;
                      #if(UART_RX_INTERRUPT_ENABLED && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
                          UART_DisableRxInt();
                      #endif /* End UART_RX_INTERRUPT_ENABLED */
                  #endif /* End UART_RX_ENABLED */
 258   1          
 259   1          #if(UART_TX_ENABLED)
 260   1              UART_TXSTATUS_ACTL_REG &= ~UART_INT_ENABLE;
 261   1              #if(UART_TX_INTERRUPT_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
                          UART_DisableTxInt();
                      #endif /* End UART_TX_INTERRUPT_ENABLED */
 264   1          #endif /* End UART_TX_ENABLED */
 265   1      
 266   1          CyExitCriticalSection(enableInterrupts);
 267   1      }
 268          
 269          
 270          /*******************************************************************************
 271          * Function Name: UART_ReadControlRegister
 272          ********************************************************************************
 273          *
 274          * Summary:
 275          *  Read the current state of the control register
 276          *
 277          * Parameters:
 278          *  None.
 279          *
 280          * Return:
 281          *  Current state of the control register.
 282          *
 283          *******************************************************************************/
 284          uint8 UART_ReadControlRegister(void) 
 285          {
 286   1          #if( UART_CONTROL_REG_REMOVED )
 287   1              return(0u);
 288   1          #else
                      return(UART_CONTROL_REG);
                  #endif /* End UART_CONTROL_REG_REMOVED */
 291   1      }
 292          
 293          
 294          /*******************************************************************************
 295          * Function Name: UART_WriteControlRegister
 296          ********************************************************************************
 297          *
 298          * Summary:
 299          *  Writes an 8-bit value into the control register
 300          *
 301          * Parameters:
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 6   

 302          *  control:  control register value
 303          *
 304          * Return:
 305          *  None.
 306          *
 307          *******************************************************************************/
 308          void  UART_WriteControlRegister(uint8 control) 
 309          {
 310   1          #if( UART_CONTROL_REG_REMOVED )
 311   1              control = control;      /* Reassigning to release compiler warning */ 
 312   1          #else
                     UART_CONTROL_REG = control;
                  #endif /* End UART_CONTROL_REG_REMOVED */
 315   1      }
 316          
 317          
 318          #if(UART_RX_ENABLED || UART_HD_ENABLED)
              
                  #if(UART_RX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: UART_EnableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_EnableRxInt(void) 
                      {
                          CyIntEnable(UART_RX_VECT_NUM);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: UART_DisableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_DisableRxInt(void) 
                      {
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 7   

                          CyIntDisable(UART_RX_VECT_NUM);
                      }
              
                  #endif /* UART_RX_INTERRUPT_ENABLED */
              
              
                  /*******************************************************************************
                  * Function Name: UART_SetRxInterruptMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configure which status bits trigger an interrupt event
                  *
                  * Parameters:
                  *  IntSrc:  An or'd combination of the desired status bit masks (defined in
                  *           the header file)
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Enables the output of specific status bits to the interrupt controller
                  *
                  *******************************************************************************/
                  void UART_SetRxInterruptMode(uint8 intSrc) 
                  {
                      UART_RXSTATUS_MASK_REG  = intSrc;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_ReadRxData
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns data in RX Data register without checking status register to 
                  *  determine if data is valid
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Received data from RX register
                  *
                  * Global Variables:
                  *  UART_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_rxBufferWrite - cyclic index for write to rxBuffer, 
                  *     checked to identify new data. 
                  *  UART_rxBufferRead - cyclic index for read from rxBuffer, 
                  *     incremented after each byte has been read from buffer.
                  *  UART_rxBufferLoopDetect - creared if loop condition was detected
                  *     in RX ISR. 
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint8 UART_ReadRxData(void) 
                  {
                      uint8 rxData;
              
                      #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 8   

              
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_RX_INTERRUPT_ENABLED)
                              UART_DisableRxInt();
                          #endif /* End UART_RX_INTERRUPT_ENABLED */
              
                          if( (UART_rxBufferRead != UART_rxBufferWrite) ||
                              (UART_rxBufferLoopDetect > 0u) )
                          {
              
                              rxData = UART_rxBuffer[UART_rxBufferRead];
              
                              UART_rxBufferRead++;
              
                              if(UART_rxBufferRead >= UART_RXBUFFERSIZE)
                              {
                                  UART_rxBufferRead = 0u;
                              }
              
                              if(UART_rxBufferLoopDetect > 0u )
                              {
                                  UART_rxBufferLoopDetect = 0u;
                                  #if( (UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u) && \
                                       (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_HD_ENABLED )
                                          if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0)
                                          {   /* In Half duplex mode return RX mask only in RX 
                                              *  configuration set, otherwise 
                                              *  mask will be returned in LoadRxConfig() API. 
                                              */
                                              UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_HD_ENABLED */
                                  #endif /* UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
                          }
                          else
                          {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                              rxData = UART_RXDATA_REG;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_RX_INTERRUPT_ENABLED)
                              UART_EnableRxInt();
                          #endif /* End UART_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
              
                          /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                          rxData = UART_RXDATA_REG;
              
                      #endif /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
              
                      return(rxData);
                  }
              
              
                  /*******************************************************************************
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 9   

                  * Function Name: UART_ReadRxStatus
                  ********************************************************************************
                  *
                  * Summary:
                  *  Read the current state of the status register
                  *  And detect software buffer overflow.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Current state of the status register.
                  *
                  * Global Variables:
                  *  UART_rxBufferOverflow - used to indicate overload condition. 
                  *   It set to one in RX interrupt when there isn?t free space in 
                  *   UART_rxBufferRead to write new data. This condition returned 
                  *   and cleared to zero by this API as an 
                  *   UART_RX_STS_SOFT_BUFF_OVER bit along with RX Status register 
                  *   bits.
                  *
                  *******************************************************************************/
                  uint8 UART_ReadRxStatus(void) 
                  {
                      uint8 status;
              
                      status = UART_RXSTATUS_REG;
                      status &= UART_RX_HW_MASK;
              
                      #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
                          if( UART_rxBufferOverflow )
                          {
                              status |= UART_RX_STS_SOFT_BUFF_OVER;
                              UART_rxBufferOverflow = 0u;
                          }
                      #endif /* UART_RXBUFFERSIZE */
              
                      return(status);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_GetChar
                  ********************************************************************************
                  *
                  * Summary:
                  *  Reads UART RX buffer immediately, if data is not available or an error 
                  *  condition exists, zero is returned; otherwise, character is read and 
                  *  returned.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
                  *  A returned zero signifies an error condition or no data available.
                  *
                  * Global Variables:
                  *  UART_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_rxBufferWrite - cyclic index for write to rxBuffer, 
                  *     checked to identify new data. 
                  *  UART_rxBufferRead - cyclic index for read from rxBuffer, 
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 10  

                  *     incremented after each byte has been read from buffer.
                  *  UART_rxBufferLoopDetect - creared if loop condition was detected
                  *     in RX ISR. 
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint8 UART_GetChar(void) 
                  {
                      uint8 rxData = 0u;
                      uint8 rxStatus;
              
                      #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
              
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_RX_INTERRUPT_ENABLED)
                              UART_DisableRxInt();
                          #endif /* UART_RX_INTERRUPT_ENABLED */
              
                          if( (UART_rxBufferRead != UART_rxBufferWrite) ||
                              (UART_rxBufferLoopDetect > 0u) )
                          {
                              rxData = UART_rxBuffer[UART_rxBufferRead];
              
                              UART_rxBufferRead++;
              
                              if(UART_rxBufferRead >= UART_RXBUFFERSIZE)
                              {
                                  UART_rxBufferRead = 0u;
                              }
              
                              if(UART_rxBufferLoopDetect > 0u ) 
                              {
                                  UART_rxBufferLoopDetect = 0u;
                                  #if( (UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u) && \
                                       (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_HD_ENABLED )
                                          if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0)
                                          {   /* In Half duplex mode return RX mask only if 
                                              *  RX configuration set, otherwise 
                                              *  mask will be returned in LoadRxConfig() API. 
                                              */
                                              UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_HD_ENABLED */
                                  #endif /* UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
              
                          }
                          else
                          {   rxStatus =UART_RXSTATUS_REG;
                              if(rxStatus & UART_RX_STS_FIFO_NOTEMPTY)
                              {   /* Read received data from FIFO*/
                                  rxData = UART_RXDATA_REG;
                                  /*Check status on error*/
                                  if(rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
                                                 UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN))
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 11  

                                  {
                                      rxData = 0u;
                                  }    
                              }
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_RX_INTERRUPT_ENABLED)
                              UART_EnableRxInt();
                          #endif /* UART_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
              
                          rxStatus =UART_RXSTATUS_REG;
                          if(rxStatus & UART_RX_STS_FIFO_NOTEMPTY)
                          {   /* Read received data from FIFO*/
                              rxData = UART_RXDATA_REG;
                              /*Check status on error*/
                              if(rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
                                             UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN))
                              {
                                  rxData = 0u;
                              }
                          }
                      #endif /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
              
                      return(rxData);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_GetByte
                  ********************************************************************************
                  *
                  * Summary:
                  *  Grab the next available byte of data from the recieve FIFO
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  MSB contains Status Register and LSB contains UART RX data
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint16 UART_GetByte(void) 
                  {
                      return ( ((uint16)UART_ReadRxStatus() << 8u) | UART_ReadRxData() );
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_GetRxBufferSize
                  ********************************************************************************
                  *
                  * Summary:
                  *  Determine the amount of bytes left in the RX buffer and return the count in
                  *  bytes
                  *
                  * Parameters:
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 12  

                  *  None.
                  *
                  * Return:
                  *  uint8: Integer count of the number of bytes left 
                  *  in the RX buffer
                  *
                  * Global Variables:
                  *  UART_rxBufferWrite - used to calculate left bytes. 
                  *  UART_rxBufferRead - used to calculate left bytes.
                  *  UART_rxBufferLoopDetect - checked to decide left bytes amount. 
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Allows the user to find out how full the RX Buffer is.
                  *
                  *******************************************************************************/
                  uint8 UART_GetRxBufferSize(void) 
                                                                          
                  {
                      uint8 size;
              
                      #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
              
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_RX_INTERRUPT_ENABLED)
                              UART_DisableRxInt();
                          #endif /* UART_RX_INTERRUPT_ENABLED */
              
                          if(UART_rxBufferRead == UART_rxBufferWrite)
                          {
                              if(UART_rxBufferLoopDetect > 0u)
                              {
                                  size = UART_RXBUFFERSIZE;
                              }
                              else
                              {
                                  size = 0u;
                              }
                          }
                          else if(UART_rxBufferRead < UART_rxBufferWrite)
                          {
                              size = (UART_rxBufferWrite - UART_rxBufferRead);
                          }
                          else
                          {
                              size = (UART_RXBUFFERSIZE - UART_rxBufferRead) + UART_rxBufferWrite;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_RX_INTERRUPT_ENABLED)
                              UART_EnableRxInt();
                          #endif /* End UART_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
              
                          /* We can only know if there is data in the fifo. */
                          size = (UART_RXSTATUS_REG & UART_RX_STS_FIFO_NOTEMPTY) ? 1u : 0u;
              
                      #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 13  

              
                      return(size);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_ClearRxBuffer
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
                  *  Clears hardware RX FIFO.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_rxBufferWrite - cleared to zero. 
                  *  UART_rxBufferRead - cleared to zero.
                  *  UART_rxBufferLoopDetect - cleared to zero. 
                  *  UART_rxBufferOverflow - cleared to zero. 
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Setting the pointers to zero makes the system believe there is no data to 
                  *  read and writing will resume at address 0 overwriting any data that may 
                  *  have remained in the RAM.
                  *
                  * Side Effects:
                  *  Any received data not read from the RAM or FIFO buffer will be lost.
                  *******************************************************************************/
                  void UART_ClearRxBuffer(void) 
                  {
                      uint8 enableInterrupts;
                      
                      /* clear the HW FIFO */
                      /* Enter critical section */
                      enableInterrupts = CyEnterCriticalSection();        
                      UART_RXDATA_AUX_CTL_REG |=  UART_RX_FIFO_CLR;
                      UART_RXDATA_AUX_CTL_REG &= ~UART_RX_FIFO_CLR;
                      /* Exit critical section */
                      CyExitCriticalSection(enableInterrupts);
                      
                      #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_RX_INTERRUPT_ENABLED)
                              UART_DisableRxInt();
                          #endif /* End UART_RX_INTERRUPT_ENABLED */
              
                          UART_rxBufferRead = 0u;
                          UART_rxBufferWrite = 0u;
                          UART_rxBufferLoopDetect = 0u;
                          UART_rxBufferOverflow = 0u;
              
                          /* Enable Rx interrupt. */
                          #if(UART_RX_INTERRUPT_ENABLED)
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 14  

                              UART_EnableRxInt();
                          #endif /* End UART_RX_INTERRUPT_ENABLED */
                      #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
                      
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_SetRxAddressMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Set the receive addressing mode
                  *
                  * Parameters:
                  *  addressMode: Enumerated value indicating the mode of RX addressing
                  *  UART__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address 
                  *                                               detection
                  *  UART__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer 
                  *                                               address detection
                  *  UART__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address 
                  *                                               detection
                  *  UART__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer 
                  *                                               address detection
                  *  UART__B_UART__AM_NONE - No address detection
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_rxAddressMode - the parameter stored in this variable for 
                  *   the farther usage in RX ISR.
                  *  UART_rxAddressDetected - set to initial state (0).
                  *
                  *******************************************************************************/
                  void UART_SetRxAddressMode(uint8 addressMode)  
                                                                      
                  {
                      #if(UART_RXHW_ADDRESS_ENABLED)
                          #if(UART_CONTROL_REG_REMOVED)
                              addressMode = addressMode;
                          #else /* UART_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl = 0u;
                              tmpCtrl = UART_CONTROL_REG & ~UART_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= ((addressMode << UART_CTRL_RXADDR_MODE0_SHIFT) & 
                                         UART_CTRL_RXADDR_MODE_MASK);
                              UART_CONTROL_REG = tmpCtrl;
                              #if(UART_RX_INTERRUPT_ENABLED && \
                                 (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
                                  UART_rxAddressMode = addressMode;
                                  UART_rxAddressDetected = 0u;
                              #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH*/   
                          #endif /* End UART_CONTROL_REG_REMOVED */
                      #else /* UART_RXHW_ADDRESS_ENABLED */
                          addressMode = addressMode;
                      #endif /* End UART_RXHW_ADDRESS_ENABLED */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_SetRxAddress1
                  ********************************************************************************
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 15  

                  *
                  * Summary:
                  *  Set the first hardware address compare value
                  *
                  * Parameters:
                  *  address
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void UART_SetRxAddress1(uint8 address) 
              
                  {
                      UART_RXADDRESS1_REG = address;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_SetRxAddress2
                  ********************************************************************************
                  *
                  * Summary:
                  *  Set the second hardware address compare value
                  *
                  * Parameters:
                  *  address
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void UART_SetRxAddress2(uint8 address) 
                  {
                      UART_RXADDRESS2_REG = address;
                  }
                      
              #endif  /* UART_RX_ENABLED || UART_HD_ENABLED*/
 898          
 899          
 900          #if( (UART_TX_ENABLED) || (UART_HD_ENABLED) )
 901          
 902              #if(UART_TX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: UART_EnableTxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable TX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_EnableTxInt(void) 
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 16  

                      {
                          CyIntEnable(UART_TX_VECT_NUM);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: UART_DisableTxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable TX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_DisableTxInt(void) 
                      {
                          CyIntDisable(UART_TX_VECT_NUM);
                      }
              
                  #endif /* UART_TX_INTERRUPT_ENABLED */
 950          
 951          
 952              /*******************************************************************************
 953              * Function Name: UART_SetTxInterruptMode
 954              ********************************************************************************
 955              *
 956              * Summary:
 957              *  Configure which status bits trigger an interrupt event
 958              *
 959              * Parameters:
 960              *  intSrc: An or'd combination of the desired status bit masks (defined in
 961              *          the header file)
 962              *
 963              * Return:
 964              *  None.
 965              *
 966              * Theory:
 967              *  Enables the output of specific status bits to the interrupt controller
 968              *
 969              *******************************************************************************/
 970              void UART_SetTxInterruptMode(uint8 intSrc) 
 971              {
 972   1              UART_TXSTATUS_MASK_REG = intSrc;
 973   1          }
 974          
 975          
 976              /*******************************************************************************
 977              * Function Name: UART_WriteTxData
 978              ********************************************************************************
 979              *
 980              * Summary:
 981              *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the 
 982              *  bus is available. WriteTxData sends a byte without checking for buffer room 
 983              *  or status. It is up to the user to separately check status.    
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 17  

 984              *
 985              * Parameters:
 986              *  TXDataByte: byte of data to place in the transmit FIFO
 987              *
 988              * Return:
 989              * void
 990              *
 991              * Global Variables:
 992              *  UART_txBuffer - RAM buffer pointer for save data for transmission
 993              *  UART_txBufferWrite - cyclic index for write to txBuffer, 
 994              *    incremented after each byte saved to buffer.
 995              *  UART_txBufferRead - cyclic index for read from txBuffer, 
 996              *    checked to identify the condition to write to FIFO directly or to TX buffer
 997              *  UART_initVar - checked to identify that the component has been  
 998              *    initialized.
 999              *
1000              * Reentrant:
1001              *  No.
1002              *
1003              *******************************************************************************/
1004              void UART_WriteTxData(uint8 txDataByte) 
1005              {
1006   1              /* If not Initialized then skip this function*/
1007   1              if(UART_initVar != 0u)
1008   1              {
1009   2                  #if(UART_TXBUFFERSIZE > UART_FIFO_LENGTH)
              
                              /* Disable Tx interrupt. */
                              /* Protect variables that could change on interrupt. */
                              #if(UART_TX_INTERRUPT_ENABLED)
                                  UART_DisableTxInt();
                              #endif /* End UART_TX_INTERRUPT_ENABLED */
              
                              if( (UART_txBufferRead == UART_txBufferWrite) &&
                                 !(UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) )
                              {
                                  /* Add directly to the FIFO. */
                                  UART_TXDATA_REG = txDataByte;
                              }
                              else
                              {
                                  if(UART_txBufferWrite >= UART_TXBUFFERSIZE)
                                  {
                                      UART_txBufferWrite = 0;
                                  }
              
                                  UART_txBuffer[UART_txBufferWrite] = txDataByte;
              
                                  /* Add to the software buffer. */
                                  UART_txBufferWrite++;
              
                              }
              
                              /* Enable Tx interrupt. */
                              #if(UART_TX_INTERRUPT_ENABLED)
                                  UART_EnableTxInt();
                              #endif /* End UART_TX_INTERRUPT_ENABLED */
              
                          #else /* UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1043   2      
1044   2                      /* Add directly to the FIFO. */
1045   2                      UART_TXDATA_REG = txDataByte;
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 18  

1046   2      
1047   2                  #endif /* End UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1048   2              }
1049   1          }
1050          
1051          
1052              /*******************************************************************************
1053              * Function Name: UART_ReadTxStatus
1054              ********************************************************************************
1055              *
1056              * Summary:
1057              *  Read the status register for the component
1058              *
1059              * Parameters:
1060              *  None.
1061              *
1062              * Return:
1063              *  Contents of the status register
1064              *
1065              * Theory:
1066              *  This function reads the status register which is clear on read. It is up to 
1067              *  the user to handle all bits in this return value accordingly, even if the bit 
1068              *  was not enabled as an interrupt source the event happened and must be handled
1069              *  accordingly.    
1070              *
1071              *******************************************************************************/
1072              uint8 UART_ReadTxStatus(void) 
1073              {
1074   1              return(UART_TXSTATUS_REG);
1075   1          }
1076          
1077          
1078              /*******************************************************************************
1079              * Function Name: UART_PutChar
1080              ********************************************************************************
1081              *
1082              * Summary:
1083              *  Wait to send byte until TX register or buffer has room.
1084              *
1085              * Parameters:
1086              *  txDataByte: The 8-bit data value to send across the UART.
1087              *
1088              * Return:
1089              *  None.
1090              *
1091              * Global Variables:
1092              *  UART_txBuffer - RAM buffer pointer for save data for transmission
1093              *  UART_txBufferWrite - cyclic index for write to txBuffer, 
1094              *     checked to identify free space in txBuffer and incremented after each byte 
1095              *     saved to buffer.
1096              *  UART_txBufferRead - cyclic index for read from txBuffer, 
1097              *     checked to identify free space in txBuffer.
1098              *  UART_initVar - checked to identify that the component has been  
1099              *     initialized.
1100              *
1101              * Reentrant:
1102              *  No.
1103              *
1104              * Theory:
1105              *  Allows the user to transmit any byte of data in a single transfer
1106              *
1107              *******************************************************************************/
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 19  

1108              void UART_PutChar(uint8 txDataByte) 
1109              {
1110   1                  #if(UART_TXBUFFERSIZE > UART_FIFO_LENGTH)
              
                              /* Block if buffer is full, so we dont overwrite. */
                              while( UART_txBufferWrite == (UART_txBufferRead - 1u) ||
                                  (uint8)(UART_txBufferWrite - UART_txBufferRead) ==
                                  (uint8)(UART_TXBUFFERSIZE - 1u) )
                              {
                                  /* Software buffer is full. */
                              }
                              /* Disable Tx interrupt. */
                              /* Protect variables that could change on interrupt. */
                              #if(UART_TX_INTERRUPT_ENABLED)
                                  UART_DisableTxInt();
                              #endif /* End UART_TX_INTERRUPT_ENABLED */
              
                              if( (UART_txBufferRead == UART_txBufferWrite) &&
                                 !(UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) )
                              {
                                  /* Add directly to the FIFO. */
                                  UART_TXDATA_REG = txDataByte;
                              }
                              else
                              {
                                  if(UART_txBufferWrite >= UART_TXBUFFERSIZE)
                                  {
                                      UART_txBufferWrite = 0;
                                  }
              
                                  UART_txBuffer[UART_txBufferWrite] = txDataByte;
              
                                  /* Add to the software buffer. */
                                  UART_txBufferWrite++;
              
                              }
              
                              /* Enable Rx interrupt. */
                              #if(UART_TX_INTERRUPT_ENABLED)
                                  UART_EnableTxInt();
                              #endif /* End UART_TX_INTERRUPT_ENABLED */
              
                          #else /* UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1151   1      
1152   1                      /* Block if there isnt room. */
1153   1                      while(UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL);
1154   1      
1155   1                      /* Add directly to the FIFO. */
1156   1                      UART_TXDATA_REG = txDataByte;
1157   1      
1158   1                  #endif /* End UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1159   1          }
1160          
1161          
1162              /*******************************************************************************
1163              * Function Name: UART_PutString
1164              ********************************************************************************
1165              *
1166              * Summary:
1167              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1168              *
1169              * Parameters:
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 20  

1170              *  string: char pointer to character string of Data to Send.
1171              *
1172              * Return:
1173              *  None.
1174              *
1175              * Global Variables:
1176              *  UART_initVar - checked to identify that the component has been  
1177              *     initialized.
1178              *
1179              * Reentrant:
1180              *  No.
1181              *
1182              * Theory:
1183              *  This function will block if there is not enough memory to place the whole 
1184              *  string, it will block until the entire string has been written to the 
1185              *  transmit buffer.
1186              *
1187              *******************************************************************************/
1188              void UART_PutString(char* string) 
1189              {
1190   1              /* If not Initialized then skip this function*/
1191   1              if(UART_initVar != 0u)
1192   1              {
1193   2                  /* This is a blocking function, it will not exit until all data is sent*/
1194   2                  while(*string != 0u)
1195   2                  {
1196   3                      UART_PutChar(*string++);
1197   3                  }
1198   2              }
1199   1          }
1200          
1201          
1202              /*******************************************************************************
1203              * Function Name: UART_PutArray
1204              ********************************************************************************
1205              *
1206              * Summary:
1207              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1208              *
1209              * Parameters:
1210              *  string: Address of the memory array residing in RAM or ROM.
1211              *  byteCount: Number of Bytes to be transmitted.
1212              *
1213              * Return:
1214              *  None.
1215              *
1216              * Global Variables:
1217              *  UART_initVar - checked to identify that the component has been  
1218              *     initialized.
1219              *
1220              * Reentrant:
1221              *  No.
1222              *
1223              *******************************************************************************/
1224              void UART_PutArray(uint8* string, uint8 byteCount) 
1225                                                                              
1226              {
1227   1              /* If not Initialized then skip this function*/
1228   1              if(UART_initVar != 0u)
1229   1              {
1230   2                  while(byteCount > 0u)
1231   2                  {
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 21  

1232   3                      UART_PutChar(*string++);
1233   3                      byteCount--;
1234   3                  }
1235   2              }
1236   1          }
1237          
1238          
1239              /*******************************************************************************
1240              * Function Name: UART_PutCRLF
1241              ********************************************************************************
1242              *
1243              * Summary:
1244              *  Write a character and then carriage return and line feed.
1245              *
1246              * Parameters:
1247              *  txDataByte: uint8 Character to send.
1248              *
1249              * Return:
1250              *  None.
1251              *
1252              * Global Variables:
1253              *  UART_initVar - checked to identify that the component has been  
1254              *     initialized.
1255              *
1256              * Reentrant:
1257              *  No.
1258              *
1259              *******************************************************************************/
1260              void UART_PutCRLF(uint8 txDataByte) 
1261              {
1262   1              /* If not Initialized then skip this function*/
1263   1              if(UART_initVar != 0u)
1264   1              {
1265   2                  UART_PutChar(txDataByte);
1266   2                  UART_PutChar(0x0Du);
1267   2                  UART_PutChar(0x0Au);
1268   2              }
1269   1          }
1270          
1271          
1272              /*******************************************************************************
1273              * Function Name: UART_GetTxBufferSize
1274              ********************************************************************************
1275              *
1276              * Summary:
1277              *  Determine the amount of space left in the TX buffer and return the count in
1278              *  bytes
1279              *
1280              * Parameters:
1281              *  None.
1282              *
1283              * Return:
1284              *  Integer count of the number of bytes left in the TX buffer
1285              *
1286              * Global Variables:
1287              *  UART_txBufferWrite - used to calculate left space. 
1288              *  UART_txBufferRead - used to calculate left space.
1289              *
1290              * Reentrant:
1291              *  No.
1292              *
1293              * Theory:
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 22  

1294              *  Allows the user to find out how full the TX Buffer is.
1295              *
1296              *******************************************************************************/
1297              uint8 UART_GetTxBufferSize(void) 
1298                                                                      
1299              {
1300   1              uint8 size;
1301   1      
1302   1              #if(UART_TXBUFFERSIZE > UART_FIFO_LENGTH)
              
                          /* Disable Tx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_TX_INTERRUPT_ENABLED)
                              UART_DisableTxInt();
                          #endif /* End UART_TX_INTERRUPT_ENABLED */
              
                          if(UART_txBufferRead == UART_txBufferWrite)
                          {
                              size = 0u;
                          }
                          else if(UART_txBufferRead < UART_txBufferWrite)
                          {
                              size = (UART_txBufferWrite - UART_txBufferRead);
                          }
                          else
                          {
                              size = (UART_TXBUFFERSIZE - UART_txBufferRead) + UART_txBufferWrite;
                          }
              
                          /* Enable Tx interrupt. */
                          #if(UART_TX_INTERRUPT_ENABLED)
                              UART_EnableTxInt();
                          #endif /* End UART_TX_INTERRUPT_ENABLED */
              
                      #else /* UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1329   1      
1330   1                  size = UART_TXSTATUS_REG;
1331   1      
1332   1                  /* Is the fifo is full. */
1333   1                  if(size & UART_TX_STS_FIFO_FULL)
1334   1                  {
1335   2                      size = UART_FIFO_LENGTH;
1336   2                  }
1337   1                  else if(size & UART_TX_STS_FIFO_EMPTY)
1338   1                  {
1339   2                      size = 0u;
1340   2                  }
1341   1                  else
1342   1                  {
1343   2                      /* We only know there is data in the fifo. */
1344   2                      size = 1u;
1345   2                  }
1346   1      
1347   1              #endif /* End UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1348   1      
1349   1              return(size);
1350   1          }
1351          
1352          
1353              /*******************************************************************************
1354              * Function Name: UART_ClearTxBuffer
1355              ********************************************************************************
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 23  

1356              *
1357              * Summary:
1358              *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1359              *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1360              *
1361              * Parameters:
1362              *  None.
1363              *
1364              * Return:
1365              *  None.
1366              *
1367              * Global Variables:
1368              *  UART_txBufferWrite - cleared to zero. 
1369              *  UART_txBufferRead - cleared to zero.
1370              *
1371              * Reentrant:
1372              *  No.
1373              *
1374              * Theory:
1375              *  Setting the pointers to zero makes the system believe there is no data to 
1376              *  read and writing will resume at address 0 overwriting any data that may have
1377              *  remained in the RAM.
1378              *
1379              * Side Effects:
1380              *  Any received data not read from the RAM buffer will be lost when overwritten.
1381              *
1382              *******************************************************************************/
1383              void UART_ClearTxBuffer(void) 
1384              {
1385   1              uint8 enableInterrupts;
1386   1              
1387   1              /* Enter critical section */
1388   1              enableInterrupts = CyEnterCriticalSection();        
1389   1              /* clear the HW FIFO */
1390   1              UART_TXDATA_AUX_CTL_REG |=  UART_TX_FIFO_CLR;
1391   1              UART_TXDATA_AUX_CTL_REG &= ~UART_TX_FIFO_CLR;
1392   1              /* Exit critical section */
1393   1              CyExitCriticalSection(enableInterrupts);
1394   1      
1395   1              #if(UART_TXBUFFERSIZE > UART_FIFO_LENGTH)
              
                          /* Disable Tx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_TX_INTERRUPT_ENABLED)
                              UART_DisableTxInt();
                          #endif /* End UART_TX_INTERRUPT_ENABLED */
              
                          UART_txBufferRead = 0u;
                          UART_txBufferWrite = 0u;
              
                          /* Enable Tx interrupt. */
                          #if(UART_TX_INTERRUPT_ENABLED)
                              UART_EnableTxInt();
                          #endif /* End UART_TX_INTERRUPT_ENABLED */
              
                      #endif /* End UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1412   1          }
1413          
1414          
1415              /*******************************************************************************
1416              * Function Name: UART_SendBreak
1417              ********************************************************************************
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 24  

1418              *
1419              * Summary:
1420              *  Write a Break command to the UART
1421              *
1422              * Parameters:
1423              *  uint8 retMode:  Wait mode,
1424              *   0 - Initialize registers for Break, sends the Break signal and return 
1425              *       imediately.
1426              *   1 - Wait until Break sending is complete, reinitialize registers to normal
1427              *       transmission mode then return.
1428              *   2 - Reinitialize registers to normal transmission mode then return.
1429              *   3 - both steps: 0 and 1
1430              *       init registers for Break, send Break signal
1431              *       wait until Break sending is complete, reinit registers to normal
1432              *       transmission mode then return.
1433              *
1434              * Return:
1435              *  None.
1436              *
1437              * Global Variables:
1438              *  UART_initVar - checked to identify that the component has been  
1439              *     initialized.
1440              *  tx_period - static variable, used for keeping TX period configuration.
1441              *
1442              * Reentrant:
1443              *  No.
1444              *
1445              * Theory:
1446              *  SendBreak function initializes registers to send 13-bit break signal. It is
1447              *  important to return the registers configuration to normal for continue 8-bit
1448              *  operation.
1449              *  Trere are 3 variants for this API usage:
1450              *  1) SendBreak(3) - function will send the Break signal and take care on the
1451              *     configuration returning. Funcition will block CPU untill transmition 
1452              *     complete.
1453              *  2) User may want to use bloking time if UART configured to the low speed 
1454              *     operation
1455              *     Emample for this case:
1456              *     SendBreak(0);     - init Break signal transmition
1457              *         Add your code here to use CPU time
1458              *     SendBreak(1);     - complete Break operation
1459              *  3) Same to 2) but user may want to init and use the interrupt for complete 
1460              *     break operation.
1461              *     Example for this case:
1462              *     Init TX interrupt whith "TX - On TX Complete" parameter
1463              *     SendBreak(0);     - init Break signal transmition
1464              *         Add your code here to use CPU time
1465              *     When interrupt appear with UART_TX_STS_COMPLETE status:
1466              *     SendBreak(2);     - complete Break operation
1467              *
1468              * Side Effects:
1469              *   Uses static variable to keep registers configuration.
1470              *
1471              *******************************************************************************/
1472              void UART_SendBreak(uint8 retMode) 
1473              {
1474   1      
1475   1              /* If not Initialized then skip this function*/
1476   1              if(UART_initVar != 0u)
1477   1              {
1478   2                  /*Set the Counter to 13-bits and transmit a 00 byte*/
1479   2                  /*When that is done then reset the counter value back*/
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 25  

1480   2                  uint8 tmpStat;
1481   2      
1482   2                  #if(UART_HD_ENABLED) /* Half Duplex mode*/
              
                              if( (retMode == UART_SEND_BREAK) ||
                                  (retMode == UART_SEND_WAIT_REINIT ) )
                              {
                                  /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
                                  UART_WriteControlRegister(UART_ReadControlRegister() |
                                                                        UART_CTRL_HD_SEND_BREAK);
                                  /* Send zeros*/
                                  UART_TXDATA_REG = 0u;
              
                                  do /*wait until transmit starts*/
                                  {
                                      tmpStat = UART_TXSTATUS_REG;
                                  }while(tmpStat & UART_TX_STS_FIFO_EMPTY);
                              }
              
                              if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_SEND_WAIT_REINIT) )
                              {
                                  do /*wait until transmit complete*/
                                  {
                                      tmpStat = UART_TXSTATUS_REG;
                                  }while(~tmpStat & UART_TX_STS_COMPLETE);
                              }
              
                              if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_REINIT) ||
                                  (retMode == UART_SEND_WAIT_REINIT) )
                              {
                                  UART_WriteControlRegister(UART_ReadControlRegister() &
                                                                       ~UART_CTRL_HD_SEND_BREAK);
                              }
              
                          #else /* UART_HD_ENABLED Full Duplex mode */
1517   2      
1518   2                      static uint8 tx_period; 
1519   2                      
1520   2                      if( (retMode == UART_SEND_BREAK) ||
1521   2                          (retMode == UART_SEND_WAIT_REINIT) )
1522   2                      {
1523   3                          /* CTRL_HD_SEND_BREAK - skip to send parity bit @ Break signal in Full Duplex mode*/
1524   3                          if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) ||
1525   3                               UART_PARITY_TYPE_SW )
1526   3                          {
1527   4                              UART_WriteControlRegister(UART_ReadControlRegister() |
1528   4                                                                    UART_CTRL_HD_SEND_BREAK);
1529   4                          }                                                          
1530   3      
1531   3                          #if(UART_TXCLKGEN_DP)
1532   3                              tx_period = UART_TXBITCLKTX_COMPLETE_REG;
1533   3                              UART_TXBITCLKTX_COMPLETE_REG = UART_TXBITCTR_BREAKBITS;
1534   3                          #else
                                      tx_period = UART_TXBITCTR_PERIOD_REG;
                                      UART_TXBITCTR_PERIOD_REG = UART_TXBITCTR_BREAKBITS8X;
                                  #endif /* End UART_TXCLKGEN_DP */
1538   3      
1539   3                          /* Send zeros*/
1540   3                          UART_TXDATA_REG = 0u;
1541   3      
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 26  

1542   3                          do /*wait until transmit starts*/
1543   3                          {
1544   4                              tmpStat = UART_TXSTATUS_REG;
1545   4                          }while(tmpStat & UART_TX_STS_FIFO_EMPTY);
1546   3                      }
1547   2      
1548   2                      if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1549   2                          (retMode == UART_SEND_WAIT_REINIT) )
1550   2                      {
1551   3                          do /*wait until transmit complete*/
1552   3                          {
1553   4                              tmpStat = UART_TXSTATUS_REG;
1554   4                          }while(~tmpStat & UART_TX_STS_COMPLETE);
1555   3                      }
1556   2      
1557   2                      if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1558   2                          (retMode == UART_REINIT) ||
1559   2                          (retMode == UART_SEND_WAIT_REINIT) )
1560   2                      {
1561   3      
1562   3                          #if(UART_TXCLKGEN_DP)
1563   3                              UART_TXBITCLKTX_COMPLETE_REG = tx_period;
1564   3                          #else
                                      UART_TXBITCTR_PERIOD_REG = tx_period;
                                  #endif /* End UART_TXCLKGEN_DP */
1567   3      
1568   3                          if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) || 
1569   3                               UART_PARITY_TYPE_SW )
1570   3                          {
1571   4                              UART_WriteControlRegister(UART_ReadControlRegister() &
1572   4                                                                   ~UART_CTRL_HD_SEND_BREAK);
1573   4                          }                                     
1574   3                      }
1575   2                  #endif    /* End UART_HD_ENABLED */
1576   2              }
1577   1          }
1578          
1579          
1580              /*******************************************************************************
1581              * Function Name: UART_SetTxAddressMode
1582              ********************************************************************************
1583              *
1584              * Summary:
1585              *  Set the transmit addressing mode
1586              *
1587              * Parameters:
1588              *  addressMode: 0 -> Space
1589              *               1 -> Mark
1590              *
1591              * Return:
1592              *  None.
1593              *
1594              *******************************************************************************/
1595              void UART_SetTxAddressMode(uint8 addressMode) 
1596              {
1597   1              /* Mark/Space sending enable*/
1598   1              if(addressMode != 0)
1599   1              {
1600   2                  UART_WriteControlRegister(UART_ReadControlRegister() | UART_CTRL_MARK);
1601   2              }
1602   1              else
1603   1              {
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 27  

1604   2                  UART_WriteControlRegister(UART_ReadControlRegister() & ~UART_CTRL_MARK);
1605   2              }
1606   1          }
1607          
1608          #endif  /* EndUART_TX_ENABLED */
1609          
1610          #if(UART_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Rx configuration if required and loads the
                  *  Tx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Tx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART. 
                  *
                  * Side Effects:
                  *  Disable RX interrupt mask, when software buffer has been used.
                  *
                  *******************************************************************************/
                  void UART_LoadTxConfig(void) 
                  {
                      #if((UART_RX_INTERRUPT_ENABLED) && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
                          /* Disable RX interrupts before set TX configuration */
                          UART_SetRxInterruptMode(0);
                      #endif /* UART_RX_INTERRUPT_ENABLED */
              
                      UART_WriteControlRegister(UART_ReadControlRegister() | UART_CTRL_HD_SEND);
                      UART_RXBITCTR_PERIOD_REG = UART_HD_TXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(UART_RXSTATUS_PTR);
                      #endif /* CY_UDB_V0 */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Tx configuration if required and loads the
                  *  Rx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Rx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 28  

                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART
                  *
                  * Side Effects:
                  *  Set RX interrupt mask based on customizer settings, when software buffer 
                  *  has been used.
                  *
                  *******************************************************************************/
                  void UART_LoadRxConfig(void) 
                  {
                      UART_WriteControlRegister(UART_ReadControlRegister() & ~UART_CTRL_HD_SEND);
                      UART_RXBITCTR_PERIOD_REG = UART_HD_RXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(UART_RXSTATUS_PTR);
                      #endif /* CY_UDB_V0 */
              
                      #if((UART_RX_INTERRUPT_ENABLED) && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
                          /* Enable RX interrupt after set RX configuration */
                          UART_SetRxInterruptMode(UART_INIT_RX_INTERRUPTS_MASK);    
                      #endif /* UART_RX_INTERRUPT_ENABLED */
                  }
              
              #endif  /* UART_HD_ENABLED */
1692          
1693          
1694          /* [] END OF FILE */
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_Start (BEGIN)
                                           ; SOURCE LINE # 76
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 79
0000 900000      R     MOV     DPTR,#UART_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 80
                                           ; SOURCE LINE # 81
0008 120000      R     LCALL   UART_Init
                                           ; SOURCE LINE # 82
000B 900000      R     MOV     DPTR,#UART_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 83
0011         ?C0001:
                                           ; SOURCE LINE # 84
0011 120000      R     LCALL   UART_Enable
                                           ; SOURCE LINE # 85
0014         ?C0002:
0014 22                RET     
             ; FUNCTION UART_Start (END)

             ; FUNCTION UART_Init (BEGIN)
                                           ; SOURCE LINE # 104
                                           ; SOURCE LINE # 105
                                           ; SOURCE LINE # 133
0000 906423            MOV     DPTR,#06423H
0003 7407              MOV     A,#07H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 134
0006 906433            MOV     DPTR,#06433H
0009 7448              MOV     A,#048H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 147
000C 906483            MOV     DPTR,#06483H
000F E4                CLR     A
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 157
0011         ?C0003:
0011 22                RET     
             ; FUNCTION UART_Init (END)

             ; FUNCTION UART_Enable (BEGIN)
                                           ; SOURCE LINE # 177
                                           ; SOURCE LINE # 178
                                           ; SOURCE LINE # 180
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 201
0008 906493            MOV     DPTR,#06493H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4410              ORL     A,#010H
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 30  

0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
0013 9043A2            MOV     DPTR,#043A2H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4402              ORL     A,#02H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 212
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 213
0026         ?C0004:
0026 22                RET     
             ; FUNCTION UART_Enable (END)

             ; FUNCTION UART_Stop (BEGIN)
                                           ; SOURCE LINE # 230
                                           ; SOURCE LINE # 231
                                           ; SOURCE LINE # 233
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 248
0008 9043A2            MOV     DPTR,#043A2H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54FD              ANL     A,#0FDH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 260
0013 906493            MOV     DPTR,#06493H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54EF              ANL     A,#0EFH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 266
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 267
0026         ?C0005:
0026 22                RET     
             ; FUNCTION UART_Stop (END)

             ; FUNCTION UART_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 284
                                           ; SOURCE LINE # 285
                                           ; SOURCE LINE # 287
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 31  

0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 291
0002         ?C0006:
0002 22                RET     
             ; FUNCTION UART_ReadControlRegister (END)

             ; FUNCTION _UART_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 308
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 311
0005 900000      R     MOV     DPTR,#control
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#control
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 315
000F         ?C0007:
000F 22                RET     
             ; FUNCTION _UART_WriteControlRegister (END)

             ; FUNCTION _UART_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 970
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 971
                                           ; SOURCE LINE # 972
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906483            MOV     DPTR,#06483H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 973
000F         ?C0008:
000F 22                RET     
             ; FUNCTION _UART_SetTxInterruptMode (END)

             ; FUNCTION _UART_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 1004
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1005
                                           ; SOURCE LINE # 1007
0005 900000      R     MOV     DPTR,#UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600A              JZ      ?C0010
                                           ; SOURCE LINE # 1008
                                           ; SOURCE LINE # 1045
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 906442            MOV     DPTR,#06442H
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 32  

                                           ; SOURCE LINE # 1048
0017         ?C0009:
                                           ; SOURCE LINE # 1049
0017         ?C0010:
0017 22                RET     
             ; FUNCTION _UART_WriteTxData (END)

             ; FUNCTION UART_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1072
                                           ; SOURCE LINE # 1073
                                           ; SOURCE LINE # 1074
0000 906463            MOV     DPTR,#06463H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1075
0005         ?C0011:
0005 22                RET     
             ; FUNCTION UART_ReadTxStatus (END)

             ; FUNCTION _UART_PutChar (BEGIN)
                                           ; SOURCE LINE # 1108
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1109
0005         ?C0012:
                                           ; SOURCE LINE # 1153
0005 906463            MOV     DPTR,#06463H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 20E2F7            JB      ACC.2,?C0012
000E         ?C0013:
                                           ; SOURCE LINE # 1156
000E 900000      R     MOV     DPTR,#txDataByte
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 906442            MOV     DPTR,#06442H
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1159
0018         ?C0014:
0018 22                RET     
             ; FUNCTION _UART_PutChar (END)

             ; FUNCTION _UART_PutString (BEGIN)
                                           ; SOURCE LINE # 1188
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1189
                                           ; SOURCE LINE # 1191
0006 900000      R     MOV     DPTR,#UART_initVar
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C 6020              JZ      ?C0018
                                           ; SOURCE LINE # 1192
000E         ?C0016:
                                           ; SOURCE LINE # 1194
000E 900000      R     MOV     DPTR,#string
0011 120000      E     LCALL   ?C?PLDXDATA
0014 120000      E     LCALL   ?C?CLDPTR
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 33  

0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 6013              JZ      ?C0018
                                           ; SOURCE LINE # 1195
                                           ; SOURCE LINE # 1196
001B 900000      R     MOV     DPTR,#string
001E E4                CLR     A
001F 75F001            MOV     B,#01H
0022 120000      E     LCALL   ?C?PLDIXDATA
0025 120000      E     LCALL   ?C?CLDPTR
0028 FF                MOV     R7,A
0029 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1197
002C 80E0              SJMP    ?C0016
002E         ?C0017:
                                           ; SOURCE LINE # 1198
002E         ?C0015:
                                           ; SOURCE LINE # 1199
002E         ?C0018:
002E 22                RET     
             ; FUNCTION _UART_PutString (END)

             ; FUNCTION _UART_PutArray (BEGIN)
                                           ; SOURCE LINE # 1224
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1226
                                           ; SOURCE LINE # 1228
000B 900000      R     MOV     DPTR,#UART_initVar
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 6024              JZ      ?C0022
                                           ; SOURCE LINE # 1229
0013         ?C0020:
                                           ; SOURCE LINE # 1230
0013 900000      R     MOV     DPTR,#byteCount
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 D3                SETB    C
001A 9400              SUBB    A,#00H
001C 4019              JC      ?C0022
                                           ; SOURCE LINE # 1231
                                           ; SOURCE LINE # 1232
001E 900000      R     MOV     DPTR,#string
0021 E4                CLR     A
0022 75F001            MOV     B,#01H
0025 120000      E     LCALL   ?C?PLDIXDATA
0028 120000      E     LCALL   ?C?CLDPTR
002B FF                MOV     R7,A
002C 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1233
002F 900000      R     MOV     DPTR,#byteCount
0032 E0                MOVX    A,@DPTR
0033 14                DEC     A
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1234
0035 80DC              SJMP    ?C0020
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 34  

0037         ?C0021:
                                           ; SOURCE LINE # 1235
0037         ?C0019:
                                           ; SOURCE LINE # 1236
0037         ?C0022:
0037 22                RET     
             ; FUNCTION _UART_PutArray (END)

             ; FUNCTION _UART_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1260
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1261
                                           ; SOURCE LINE # 1263
0005 900000      R     MOV     DPTR,#UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6012              JZ      ?C0024
                                           ; SOURCE LINE # 1264
                                           ; SOURCE LINE # 1265
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1266
0015 7F0D              MOV     R7,#0DH
0017 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1267
001A 7F0A              MOV     R7,#0AH
001C 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1268
001F         ?C0023:
                                           ; SOURCE LINE # 1269
001F         ?C0024:
001F 22                RET     
             ; FUNCTION _UART_PutCRLF (END)

             ; FUNCTION UART_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 1297
                                           ; SOURCE LINE # 1299
                                           ; SOURCE LINE # 1330
0000 906463            MOV     DPTR,#06463H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#size
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1333
000A 900000      R     MOV     DPTR,#size
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 30E208            JNB     ACC.2,?C0025
                                           ; SOURCE LINE # 1334
                                           ; SOURCE LINE # 1335
0013 900000      R     MOV     DPTR,#size
0016 7404              MOV     A,#04H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1336
0019 8016              SJMP    ?C0026
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 35  

001B         ?C0025:
                                           ; SOURCE LINE # 1337
001B 900000      R     MOV     DPTR,#size
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 30E107            JNB     ACC.1,?C0027
                                           ; SOURCE LINE # 1338
                                           ; SOURCE LINE # 1339
0024 900000      R     MOV     DPTR,#size
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1340
0029 8006              SJMP    ?C0026
002B         ?C0027:
                                           ; SOURCE LINE # 1342
                                           ; SOURCE LINE # 1344
002B 900000      R     MOV     DPTR,#size
002E 7401              MOV     A,#01H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1345
0031         ?C0028:
0031         ?C0026:
                                           ; SOURCE LINE # 1349
0031 900000      R     MOV     DPTR,#size
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
                                           ; SOURCE LINE # 1350
0036         ?C0029:
0036 22                RET     
             ; FUNCTION UART_GetTxBufferSize (END)

             ; FUNCTION UART_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 1383
                                           ; SOURCE LINE # 1384
                                           ; SOURCE LINE # 1388
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1390
0008 906492            MOV     DPTR,#06492H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1391
0013 906492            MOV     DPTR,#06492H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1393
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 36  

0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1412
0026         ?C0030:
0026 22                RET     
             ; FUNCTION UART_ClearTxBuffer (END)

             ; FUNCTION _UART_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1472
0000 900000      R     MOV     DPTR,#retMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1473
                                           ; SOURCE LINE # 1476
0005 900000      R     MOV     DPTR,#UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7003              JNZ     $ + 5H
000D 020000      R     LJMP    ?C0046
                                           ; SOURCE LINE # 1477
                                           ; SOURCE LINE # 1520
0010 900000      R     MOV     DPTR,#retMode
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 6016              JZ      ?C0034
0018 900000      R     MOV     DPTR,#retMode
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6403              XRL     A,#03H
0020 7034              JNZ     ?C0032
0022         ?C0033:
                                           ; SOURCE LINE # 1522
                                           ; SOURCE LINE # 1524
0022 800A              SJMP    ?C0034
                                           ; SOURCE LINE # 1526
                                           ; SOURCE LINE # 1527
0024 120000      R     LCALL   UART_ReadControlRegister
0027 EF                MOV     A,R7
0028 4402              ORL     A,#02H
002A FF                MOV     R7,A
002B 120000      R     LCALL   _UART_WriteControlRegister
                                           ; SOURCE LINE # 1529
002E         ?C0034:
                                           ; SOURCE LINE # 1532
002E 906433            MOV     DPTR,#06433H
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 900000      R     MOV     DPTR,#tx_period
0036 EF                MOV     A,R7
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1533
0038 906433            MOV     DPTR,#06433H
003B 7467              MOV     A,#067H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1540
003E 906442            MOV     DPTR,#06442H
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
0043         ?C0037:
                                           ; SOURCE LINE # 1543
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 37  

                                           ; SOURCE LINE # 1544
0043 906463            MOV     DPTR,#06463H
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 900000      R     MOV     DPTR,#tmpStat
004B EF                MOV     A,R7
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1545
004D         ?C0035:
004D 900000      R     MOV     DPTR,#tmpStat
0050 E0                MOVX    A,@DPTR
0051 FF                MOV     R7,A
0052 EF                MOV     A,R7
0053 20E1ED            JB      ACC.1,?C0037
0056         ?C0036:
                                           ; SOURCE LINE # 1546
0056         ?C0032:
                                           ; SOURCE LINE # 1548
0056 900000      R     MOV     DPTR,#retMode
0059 E0                MOVX    A,@DPTR
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C 6401              XRL     A,#01H
005E 6009              JZ      ?C0042
0060 900000      R     MOV     DPTR,#retMode
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
0065 EF                MOV     A,R7
0066 B40318            CJNE    A,#03H,?C0038
0069         ?C0039:
                                           ; SOURCE LINE # 1550
0069         ?C0042:
                                           ; SOURCE LINE # 1552
                                           ; SOURCE LINE # 1553
0069 906463            MOV     DPTR,#06463H
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
006E 900000      R     MOV     DPTR,#tmpStat
0071 EF                MOV     A,R7
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1554
0073         ?C0040:
0073 900000      R     MOV     DPTR,#tmpStat
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 EF                MOV     A,R7
0079 F4                CPL     A
007A FF                MOV     R7,A
007B 7E00              MOV     R6,#00H
007D EF                MOV     A,R7
007E 20E0E8            JB      ACC.0,?C0042
0081         ?C0041:
                                           ; SOURCE LINE # 1555
0081         ?C0038:
                                           ; SOURCE LINE # 1557
0081 900000      R     MOV     DPTR,#retMode
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 6401              XRL     A,#01H
0089 6013              JZ      ?C0044
008B 900000      R     MOV     DPTR,#retMode
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 38  

008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 EF                MOV     A,R7
0091 6402              XRL     A,#02H
0093 6009              JZ      ?C0044
0095 900000      R     MOV     DPTR,#retMode
0098 E0                MOVX    A,@DPTR
0099 FF                MOV     R7,A
009A EF                MOV     A,R7
009B B40315            CJNE    A,#03H,?C0046
009E         ?C0044:
                                           ; SOURCE LINE # 1560
                                           ; SOURCE LINE # 1563
009E 900000      R     MOV     DPTR,#tx_period
00A1 E0                MOVX    A,@DPTR
00A2 FF                MOV     R7,A
00A3 906433            MOV     DPTR,#06433H
00A6 EF                MOV     A,R7
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1568
00A8 22                RET     
                                           ; SOURCE LINE # 1570
                                           ; SOURCE LINE # 1571
00A9 120000      R     LCALL   UART_ReadControlRegister
00AC EF                MOV     A,R7
00AD 54FD              ANL     A,#0FDH
00AF FF                MOV     R7,A
00B0 120000      R     LCALL   _UART_WriteControlRegister
                                           ; SOURCE LINE # 1573
00B3         ?C0045:
                                           ; SOURCE LINE # 1574
00B3         ?C0043:
                                           ; SOURCE LINE # 1576
00B3         ?C0031:
                                           ; SOURCE LINE # 1577
00B3         ?C0046:
00B3 22                RET     
             ; FUNCTION _UART_SendBreak (END)

             ; FUNCTION _UART_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1595
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1596
                                           ; SOURCE LINE # 1598
0005 900000      R     MOV     DPTR,#addressMode
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600B              JZ      ?C0047
                                           ; SOURCE LINE # 1599
                                           ; SOURCE LINE # 1600
000D 120000      R     LCALL   UART_ReadControlRegister
0010 EF                MOV     A,R7
0011 4404              ORL     A,#04H
0013 FF                MOV     R7,A
0014 120000      R     LCALL   _UART_WriteControlRegister
                                           ; SOURCE LINE # 1601
0017 22                RET     
0018         ?C0047:
                                           ; SOURCE LINE # 1603
C51 COMPILER V9.03   UART                                                                  06/19/2012 10:21:29 PAGE 39  

                                           ; SOURCE LINE # 1604
0018 120000      R     LCALL   UART_ReadControlRegister
001B EF                MOV     A,R7
001C 54FB              ANL     A,#0FBH
001E FF                MOV     R7,A
001F 120000      R     LCALL   _UART_WriteControlRegister
                                           ; SOURCE LINE # 1605
0022         ?C0048:
                                           ; SOURCE LINE # 1606
0022         ?C0049:
0022 22                RET     
             ; FUNCTION _UART_SetTxAddressMode (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    651    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     21    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
